<!DOCTYPE html>
<html>
    <head>
        <title>Tenant Locations Map with Clustering, Search, and Dynamic Logo Markers</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <!-- Leaflet CSS -->
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
        <!-- Clustering CSS -->
        <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
        <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
        <!-- Search Control CSS -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/leaflet.esri.geocoder/2.1.0/esri-leaflet-geocoder.css">
        <style>
            body { margin:0; padding:0; }
            #map {
                position: absolute;
                top: 0;
                bottom: 0;
                right: 0;
                left: 320px;
            }
            #sidebar {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 0;
                width: 320px;
                background: #ffffff;
                border-right: 1px solid #ddd;
                box-shadow: 0 1px 5px rgba(0,0,0,0.1);
                font-family: Arial, sans-serif;
                overflow-y: auto;
                z-index: 1000;
            }
            .sidebar-header {
                padding: 12px 16px;
                border-bottom: 1px solid #eee;
                font-weight: bold;
            }
            .sidebar-tools {
                padding: 10px 16px;
                border-bottom: 1px solid #eee;
            }
            .sidebar-tools label {
                display: block;
                font-size: 12px;
                color: #666;
                margin-bottom: 6px;
            }
            .sidebar-tools input[type="range"] {
                width: 100%;
            }
            .sidebar-content {
                padding: 12px 16px;
                font-size: 14px;
                color: #333;
            }
            .sidebar-row {
                margin-bottom: 10px;
            }
            .sidebar-label {
                display: block;
                font-size: 12px;
                color: #666;
                margin-bottom: 2px;
            }
            .sidebar-value {
                font-size: 14px;
            }
            .chip {
                display: inline-block;
                padding: 4px 10px;
                border-radius: 999px;
                font-size: 12px;
                background: #f2f4f8;
                color: #333;
                margin-right: 6px;
            }
            .color-dot {
                display: inline-block;
                width: 10px;
                height: 10px;
                border-radius: 50%;
                margin-right: 6px;
                vertical-align: middle;
            }
            .sidebar-logo {
                width: 100%;
                height: 120px;
                background-size: contain;
                background-repeat: no-repeat;
                background-position: center;
                border-bottom: 1px solid #eee;
                margin-bottom: 8px;
            }
            .sidebar-logo-img {
                width: 100%;
                max-height: 140px;
                object-fit: contain;
                border-bottom: 1px solid #eee;
                margin-bottom: 8px;
                display: block;
            }
            .call-button {
                display: inline-block;
                margin-top: 8px;
                padding: 8px 12px;
                background: #0366d6;
                color: #fff;
                text-decoration: none;
                border-radius: 4px;
            }
            /* Popup Adjustment */
            .leaflet-popup-content { width: 240px; }
            .popup-card { font-family: Arial, sans-serif; }
            .popup-title { font-weight: 600; margin-bottom: 4px; }
            .popup-subtitle { color: #555; font-size: 13px; margin-bottom: 6px; }
            .popup-owner { color: #333; font-size: 13px; margin-bottom: 8px; }
            .popup-logo { width: 100%; max-width: 220px; height: auto; object-fit: contain; margin-bottom: 6px; display: block; }
            /* Modified Popup Styles for Minimal Look */
            .leaflet-popup-content-wrapper {
                background-color: #fff; /* White background */
                color: #333; /* Dark grey text */
                font-family: Arial, sans-serif;
                border: none; /* No border */
                box-shadow: 0 1px 3px rgba(0,0,0,0.2); /* Subtle shadow */
                padding: 5px; /* Adjusted padding */
            }
            .leaflet-popup-content {
                margin: 0; /* Removed margin */
            }
            .leaflet-popup-tip-container {
                width: 16px;
                height: 8px;
            }
            .leaflet-popup-tip {
                background: #fff;
                border: none;
                box-shadow: 0 1px 3px rgba(0,0,0,0.2); /* Subtle shadow */
            }
            .tenant-name {
                cursor: pointer;
                color: #0366d6;
                text-decoration: underline;
                font-size: 14px; /* Smaller font size */
            }
            .tenant-name:hover {
                opacity: 0.8;
            }
            .copy-notification {
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 10px 20px;
                border-radius: 5px;
                display: none;
                z-index: 1000;
            }
            .custom-div-icon {
                background: transparent;
                border: none;
            }
            /* Add new styles for the zoom level display */
            .zoom-level-control {
                background: white;
                padding: 5px 10px;
                border: 1px solid #999;
                border-radius: 4px;
                font-family: Arial, sans-serif;
                box-shadow: 0 1px 5px rgba(0,0,0,0.4);
                background: rgba(255, 255, 255, 0.9);
            }
        </style>
    </head>
    <body>
        <div id="sidebar">
            <div class="sidebar-header">Owner Details</div>
            <div class="sidebar-tools">
                <label for="logoSize">Logo Size</label>
                <input type="range" id="logoSize" min="0.6" max="1.6" step="0.1" value="1.0" />
            </div>
            <div id="sidebarContent" class="sidebar-content">
                <div class="sidebar-row"><span class="sidebar-label">Tenant</span><span class="sidebar-value">Select a location</span></div>
            </div>
        </div>
        <div id="map"></div>
        <div class="copy-notification" id="copyNotification">Copied to clipboard!</div>
        <!-- Leaflet, Clustering, and ESRI Geocoder Scripts -->
        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
        <script src="https://cdn.jsdelivr.net/leaflet.esri/2.0.0/esri-leaflet.js"></script>
        <script src="https://cdn.jsdelivr.net/leaflet.esri.geocoder/2.1.0/esri-leaflet-geocoder.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
        <script>
            

            // Copy to clipboard function using a temporary input element
            window.copyToClipboard = function(text) {
                const el = document.createElement('textarea');
                el.value = text;
                el.setAttribute('readonly', '');
                el.style.position = 'absolute';
                el.style.left = '-9999px';
                document.body.appendChild(el);
                const selected =
                    document.getSelection().rangeCount > 0
                        ? document.getSelection().getRangeAt(0)
                        : false;
                el.select();
                document.execCommand('copy');
                document.body.removeChild(el);
                if (selected) {
                    document.getSelection().removeAllRanges();
                    document.getSelection().addRange(selected);
                }

                const notification = document.getElementById('copyNotification');
                notification.style.display = 'block';
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 2000);
            }

            // Map zoom constants
            const baseZoom = 13;
            const baseHeight = 36;
            const scaleBase = 1.1;
            const MIN_H = 16;
            const MAX_H = 60;
            const MIN_W = 16;
            const MAX_W = 90;
            let userSizeMultiplier = 1.0;

            // Initialize Map and Define Base Layers - using let instead of var for proper scoping
            let map = L.map('map').setView([44.0, -120.5], 7);

            // Base layer (aquarelle style without labels)
            let baseLayer = L.tileLayer('https://api.maptiler.com/maps/aquarelle/{z}/{x}/{y}.png?key=TbsQ5qLxJHC20Jv4Th7E', {
                attribution: ''
            }).addTo(map);

            // City labels overlay
            let cityLabels = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', {
                attribution: '',
                pane: 'overlayPane'
            }).addTo(map);

            // Marker Cluster Group for Tenant Locations
            let tenantMarkers = L.markerClusterGroup({
                maxClusterRadius: 15,
                disableClusteringAtZoom: 12
            });

            // Store all tenant data for re-rendering on zoom
            let tenantData = [];
            
            // Cache for loaded images to avoid reloading on every zoom
            let imageCache = {};

            // Function to create a marker with scaled logo based on zoom level
            function createLogoMarker(tenant, zoomLevel) {
                // Use cached image dimensions if available
                if (imageCache[tenant.url]) {
                    createMarkerWithDimensions(tenant, zoomLevel, imageCache[tenant.url]);
                    return;
                }
                
                // Load image to get dimensions
                const img = new Image();
                img.onload = function() {
                    // Cache the dimensions
                    imageCache[tenant.url] = {
                        width: img.width,
                        height: img.height
                    };
                    
                    createMarkerWithDimensions(tenant, zoomLevel, imageCache[tenant.url]);
                };
                img.onerror = function() {
                    console.error("Error loading image:", tenant.url);
                    // Add a fallback marker in case of image loading error
                    const fallback = L.marker([tenant.lat, tenant.lng])
                        .bindPopup(`<div class=\"popup-card\">${tenant.url ? `<img class=\"popup-logo\" src=\"${tenant.url}\" alt=\"${tenant.name} logo\" referrerpolicy=\"no-referrer\" onerror=\"this.style.display='none'\" />` : ''}<div class=\"popup-title\">${tenant.name}</div><div class=\"popup-subtitle\">${tenant.address || ''}</div><div class=\"popup-owner\">Owner: ${tenant.owner || ''}</div>${tenant.ownerPhone ? `<a href=\"tel:${tenant.ownerPhone}\" class=\"call-button\">Call Owner</a>` : ''}</div>`);
                    fallback.on('click', function() { updateSidebar(tenant); });
                    tenantMarkers.addLayer(fallback);
                };
                img.src = tenant.url;
            }
            
            // Helper function to create marker with known dimensions
            function createMarkerWithDimensions(tenant, zoomLevel, dimensions) {
                const aspectRatio = dimensions.width / dimensions.height;
                
                // Apply logo type adjustments if available
                let adjustedRatio = aspectRatio;
                let sizeMultiplier = 1.0; // Base size multiplier

                if (tenant.logoType) {
                    switch (tenant.logoType.toLowerCase()) {
                        case 'wide':
                            // Give more width to wide logos and make them larger
                            adjustedRatio = Math.max(aspectRatio, 2.0);
                            sizeMultiplier = 1.5; // 50% larger than base size
                            break;
                        case 'circle':
                            // Keep circular logos more square-ish and slightly larger
                            adjustedRatio = Math.min(Math.max(aspectRatio, 0.9), 1.1);
                            sizeMultiplier = 1.2; // 20% larger than base size
                            break;
                        case 'tall':
                            // Compress width for tall logos and make them taller
                            adjustedRatio = Math.min(aspectRatio, 0.7);
                            sizeMultiplier = 1.3; // 30% larger than base size
                            break;
                        case 'square':
                            // Force a more square aspect ratio and slightly larger size
                            adjustedRatio = Math.min(Math.max(aspectRatio, 0.9), 1.1);
                            sizeMultiplier = 1.2; // 20% larger than base size
                            break;
                        case 'extra-wide':
                            // For extremely wide logos that need even more width
                            adjustedRatio = Math.max(aspectRatio, 2.5);
                            sizeMultiplier = 1.7; // 70% larger than base size
                            break;
                        case 'compact':
                            // For logos that need to be smaller than default
                            adjustedRatio = Math.min(Math.max(aspectRatio, 0.8), 1.2);
                            sizeMultiplier = 0.6; // 40% smaller than base size
                            break;
                        case 'extra-tall':
                            // For extremely tall logos
                            adjustedRatio = Math.min(aspectRatio, 0.5);
                            sizeMultiplier = 1.6; // 60% larger than base size
                            break;
                        case 'tiny':
                            // For logos that need to be very small
                            adjustedRatio = aspectRatio;
                            sizeMultiplier = 0.4; // 60% smaller than base size
                            break;
                        case 'small':
                            // For logos that need to be small
                            adjustedRatio = aspectRatio;
                            sizeMultiplier = 0.6; // 40% smaller than base size
                            break;
                        case 'large':
                            // For logos that need to be larger while maintaining aspect ratio
                            adjustedRatio = aspectRatio;
                            sizeMultiplier = 1.8; // 80% larger than base size
                            break;
                        default:
                            // Keep original aspect ratio if no type specified or unknown type
                            adjustedRatio = aspectRatio;
                            sizeMultiplier = 0.8; // Make default size 20% smaller
                    }
                } else {
                    // No logo type specified - use smaller default size
                    sizeMultiplier = 0.8;
                }
                
                const scaleFactor = Math.pow(scaleBase, zoomLevel - baseZoom);
                let targetHeight = baseHeight * scaleFactor * sizeMultiplier * userSizeMultiplier;
                targetHeight = Math.max(MIN_H, Math.min(MAX_H, targetHeight));
                let scaledWidth = targetHeight * adjustedRatio;
                if (scaledWidth > MAX_W) {
                    scaledWidth = MAX_W;
                    targetHeight = Math.max(MIN_H, Math.min(MAX_H, scaledWidth / adjustedRatio));
                }
                if (scaledWidth < MIN_W) {
                    scaledWidth = MIN_W;
                    targetHeight = Math.max(MIN_H, Math.min(MAX_H, scaledWidth / adjustedRatio));
                }

                const icon = L.divIcon({
                    html: `<div style="
                        width: ${scaledWidth}px;
                        height: ${targetHeight}px;
                        background-image: url('${tenant.url}');
                        background-size: contain;
                        background-repeat: no-repeat;
                        background-position: center;
                    "></div>`,
                    iconSize: [scaledWidth, targetHeight],
                    iconAnchor: [scaledWidth/2, targetHeight/2],
                    popupAnchor: [0, -targetHeight/2],
                    className: 'custom-div-icon'
                });

                const marker = L.marker([tenant.lat, tenant.lng], { icon })
                    .bindPopup(`<div class=\"popup-card\">${tenant.url ? `<img class=\"popup-logo\" src=\"${tenant.url}\" alt=\"${tenant.name} logo\" referrerpolicy=\"no-referrer\" onerror=\"this.style.display='none'\" />` : ''}<div class=\"popup-title\">${tenant.name}</div><div class=\"popup-subtitle\">${tenant.address || ''}</div><div class=\"popup-owner\">Owner: ${tenant.owner || ''}</div>${tenant.ownerPhone ? `<a href=\"tel:${tenant.ownerPhone}\" class=\"call-button\">Call Owner</a>` : ''}</div>`);
                marker.on('click', function() { updateSidebar(tenant); });
                
                tenantMarkers.addLayer(marker);
            }

            // Function to Add Tenant Markers with Logos
            function addTenantMarkers(records) {
                tenantData = [];
                tenantMarkers.clearLayers();
                records.forEach(record => {
                    const lat = parseFloat(record['Latitude']);
                    const lng = parseFloat(record['Longitude']);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        const logoUrl = record['Tenant Name_Logo-URL'] || record['Tenant_Name_Logo_URL'] || '';
                        const name = record['Tenant Name'] || record['Tenant_Name'] || '';
                        const logoType = record['Logo_Type'] || '';
                        const owner = record['Owner'] || '';
                        const ownerPhone = record['ownerPhone'] || record['Owner Phone'] || '';
                        const ownerAddress = record['Owner Address'] || '';
                        const otherOwners = record['Other Owners'] || '';
                        const ownerLastContact = record['Owner_Last_Contact'] || '';
                        const lastContact = record['LastContact'] || '';
                        const segment = record['Segment'] || '';
                        const classify = record['Classify'] || '';
                        const classifyColor = record['Classify Color'] || '';
                        const accounts = record['Accounts'] || '';
                        const tenantCategory = record['Tenant Name_Category'] || '';
                        const addressConcat = record['Address Concatenate'] || '';
                        const address = addressConcat || [record['Address'], record['City'], record['State'], record['Zip']].filter(Boolean).join(', ');
                        if (logoUrl) {
                            tenantData.push({ lat, lng, url: logoUrl, name, logoType, owner, ownerPhone, ownerAddress, otherOwners, ownerLastContact, lastContact, segment, classify, classifyColor, accounts, tenantCategory, address });
                        } else {
                            const t = { lat, lng, name, owner, ownerPhone, address };
                            const fallback = L.marker([lat, lng])
                                .bindPopup(`<div class=\"popup-card\">${logoUrl ? `<img class=\"popup-logo\" src=\"${logoUrl}\" alt=\"${name} logo\" referrerpolicy=\"no-referrer\" onerror=\"this.style.display='none'\" />` : ''}<div class=\"popup-title\">${name}</div><div class=\"popup-subtitle\">${address}</div><div class=\"popup-owner\">Owner: ${owner}</div>${ownerPhone ? `<a href=\"tel:${ownerPhone}\" class=\"call-button\">Call Owner</a>` : ''}</div>`);
                            fallback.on('click', function() { updateSidebar(t); });
                            tenantMarkers.addLayer(fallback);
                        }
                    }
                });
                renderMarkers();
                map.addLayer(tenantMarkers);
                if (tenantMarkers.getLayers().length > 0) {
                    try {
                        map.fitBounds(tenantMarkers.getBounds());
                    } catch (e) {
                        console.error("Error fitting bounds:", e);
                    }
                }
            }

            // Function to clear and re-render all markers at current zoom level
            function renderMarkers() {
                // Clear existing markers
                tenantMarkers.clearLayers();
                
                // Get current zoom level
                const currentZoom = map.getZoom();
                
                // Re-render tenants with logos using dynamic sizing
                tenantData.forEach(tenant => createLogoMarker(tenant, currentZoom));
                
                // Make sure cluster is still added to the map
                if (!map.hasLayer(tenantMarkers)) {
                    map.addLayer(tenantMarkers);
                }
            }

            // Create a custom control for zoom level display
            L.Control.ZoomLevel = L.Control.extend({
                options: {
                    position: 'bottomleft'
                },

                onAdd: function(map) {
                    this._container = L.DomUtil.create('div', 'zoom-level-control');
                    this._map = map;
                    this._updateContent();
                    return this._container;
                },

                _updateContent: function() {
                    this._container.innerHTML = 'Zoom Level: ' + this._map.getZoom();
                }
            });

            // Create and add the zoom level control to the map
            let zoomLevelControl = new L.Control.ZoomLevel();
            map.addControl(zoomLevelControl);

            // Update zoom level display whenever zoom changes
            map.on('zoomend', function() {
                zoomLevelControl._updateContent();
            });

            // Layer Control
            L.control.layers({
                'Base Map': baseLayer
            }, {
                'City Labels': cityLabels,
                'Tenant Locations': tenantMarkers
            }, {
                position: 'topright',
                collapsed: false
            }).addTo(map);

            // Search Control
            let searchControl = L.esri.Geocoding.geosearch({
                providers: [L.esri.Geocoding.arcgisOnlineProvider()],
                position: 'topleft'
            }).addTo(map);

            let searchResults = L.layerGroup().addTo(map);
            searchControl.on('results', function(data) {
                searchResults.clearLayers();
                for (var i = data.results.length - 1; i >= 0; i--) {
                    searchResults.addLayer(L.marker(data.results[i].latlng));
                }
            });

            map.on('zoomend', renderMarkers);
            
            document.addEventListener('DOMContentLoaded', function() {
                fetch('Tenants.geojson')
                    .then(r => {
                        if (!r.ok) throw new Error('GeoJSON fetch failed: ' + r.status);
                        return r.json();
                    })
                    .then(data => {
                        if (data && Array.isArray(data.features)) {
                            addGeoJsonFeatures(data);
                        } else {
                            throw new Error('Invalid GeoJSON structure');
                        }
                    })
                    .catch(err => {
                        console.warn('GeoJSON load failed, falling back to CSV:', err);
                        Papa.parse('Round%20of%20Proposals%20%233%20-%20LocationDataExport.csv', {
                            download: true,
                            header: true,
                            dynamicTyping: true,
                            skipEmptyLines: true,
                            complete: function(results) {
                                if (results && results.data && results.data.length) {
                                    addTenantMarkers(results.data);
                                } else {
                                    console.error('CSV parsed but no data rows');
                                }
                            },
                            error: function(err2) {
                                console.error('CSV load/parse error:', err2);
                            }
                        });
                    });
            });

            function addGeoJsonFeatures(geojson) {
                tenantData = [];
                tenantMarkers.clearLayers();
                geojson.features.forEach(f => {
                    if (!f || !f.geometry || f.geometry.type !== 'Point') return;
                    const coords = f.geometry.coordinates;
                    if (!Array.isArray(coords) || coords.length < 2) return;
                    const lng = parseFloat(coords[0]);
                    const lat = parseFloat(coords[1]);
                    if (isNaN(lat) || isNaN(lng)) return;
                    const p = f.properties || {};
                    const logoUrl = p['Tenant Name_Logo-URL'] || p['Tenant_Name_Logo_URL'] || '';
                    const name = p['Tenant Name'] || p['Tenant_Name'] || '';
                    const logoType = p['Logo_Type'] || '';
                    const owner = p['Owner'] || '';
                    const ownerPhone = p['ownerPhone'] || p['Owner Phone'] || '';
                    const ownerAddress = p['Owner Address'] || '';
                    const otherOwners = p['Other Owners'] || '';
                    const ownerLastContact = p['Owner_Last_Contact'] || '';
                    const lastContact = p['LastContact'] || '';
                    const segment = p['Segment'] || '';
                    const classify = p['Classify'] || '';
                    const classifyColor = p['Classify Color'] || '';
                    const accounts = p['Accounts'] || '';
                    const tenantCategory = p['Tenant Name_Category'] || '';
                    const addressConcat = p['Address Concatenate'] || '';
                    const address = addressConcat || [p['Address'], p['City'], p['State'], p['Zip']].filter(Boolean).join(', ');
                    if (logoUrl) {
                        tenantData.push({ lat, lng, url: logoUrl, name, logoType, owner, ownerPhone, ownerAddress, otherOwners, ownerLastContact, lastContact, segment, classify, classifyColor, accounts, tenantCategory, address });
                    } else {
                        const t = { lat, lng, name, owner, ownerPhone, address };
                        const fallback = L.marker([lat, lng])
                            .bindPopup(`<div class=\"popup-card\">${logoUrl ? `<img class=\"popup-logo\" src=\"${logoUrl}\" alt=\"${name} logo\" referrerpolicy=\"no-referrer\" onerror=\"this.style.display='none'\" />` : ''}<div class=\"popup-title\">${name}</div><div class=\"popup-subtitle\">${address}</div><div class=\"popup-owner\">Owner: ${owner}</div>${ownerPhone ? `<a href=\"tel:${ownerPhone}\" class=\"call-button\">Call Owner</a>` : ''}</div>`);
                        fallback.on('click', function() { updateSidebar(t); });
                        tenantMarkers.addLayer(fallback);
                    }
                });
                renderMarkers();
                map.addLayer(tenantMarkers);
                if (tenantMarkers.getLayers().length > 0) {
                    try {
                        map.fitBounds(tenantMarkers.getBounds());
                    } catch (e) {
                        console.error('Error fitting bounds:', e);
                    }
                }
            }

            function updateSidebar(tenant) {
                const el = document.getElementById('sidebarContent');
                const phoneLink = tenant.ownerPhone ? `<a href="tel:${tenant.ownerPhone}" class="call-button">Call Owner</a>` : '';
                const logoBlock = tenant.url ? `<img class="sidebar-logo-img" src="${tenant.url}" alt="${tenant.name} logo" referrerpolicy="no-referrer" onerror="this.style.display='none'" />` : '';
                const chips = `
                    ${tenant.tenantCategory ? `<span class=\"chip\">${tenant.tenantCategory}</span>` : ''}
                    ${tenant.segment ? `<span class=\"chip\">${tenant.segment}</span>` : ''}
                    ${tenant.classify ? `<span class=\"chip\"><span class=\"color-dot\" style=\"background:${tenant.classifyColor || '#999'}\"></span>${tenant.classify}</span>` : ''}
                `;
                el.innerHTML = `
                    ${logoBlock}
                    <div class="sidebar-row"><span class="sidebar-label">${tenant.name || ''}</span></div>
                    <div class="sidebar-row">${chips}</div>
                    <div class="sidebar-row"><span class="sidebar-label">Address</span><span class="sidebar-value">${tenant.address || ''}</span></div>
                    <div class="sidebar-row"><span class="sidebar-label">Owner</span><span class="sidebar-value">${tenant.owner || ''}</span></div>
                    <div class="sidebar-row"><span class="sidebar-label">Owner Address</span><span class="sidebar-value">${tenant.ownerAddress || ''}</span></div>
                    <div class="sidebar-row"><span class="sidebar-label">Other Owners</span><span class="sidebar-value">${tenant.otherOwners || ''}</span></div>
                    <div class="sidebar-row"><span class="sidebar-label">Owner Last Contact</span><span class="sidebar-value">${tenant.ownerLastContact || ''}</span></div>
                    <div class="sidebar-row"><span class="sidebar-label">Last Contact</span><span class="sidebar-value">${tenant.lastContact || ''}</span></div>
                    <div class="sidebar-row"><span class="sidebar-label">Accounts</span><span class="sidebar-value">${tenant.accounts || ''}</span></div>
                    <div class="sidebar-row"><span class="sidebar-label">Phone</span><span class="sidebar-value">${tenant.ownerPhone || ''}</span></div>
                    ${phoneLink}
                `;
            }

            document.addEventListener('DOMContentLoaded', function() {
                const slider = document.getElementById('logoSize');
                if (slider) {
                    slider.addEventListener('input', function(e) {
                        const v = parseFloat(e.target.value);
                        if (!isNaN(v)) {
                            userSizeMultiplier = v;
                            renderMarkers();
                        }
                    });
                }
            });
        </script>
    </body>
</html>
